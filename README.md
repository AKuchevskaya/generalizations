# ООП: Обобщения. дз4  

Создайте класс Pair, который будет представлять пару значений любого типа. Этот класс должен иметь два обобщенных параметра: T и U, которые будут представлять типы значений первого и второго элементов пары соответственно.

Класс Pair должен иметь следующие методы:

getFirst(): метод для получения первого элемента пары.
getSecond(): метод для получения второго элемента пары.
setFirst(T first): метод для установки значения первого элемента пары.
setSecond(U second): метод для установки значения второго элемента пары.

Пример использования:

Pair<Integer, String> pair = new Pair<>(10, "Hello");
System.out.println("First element: " + pair.getFirst());
System.out.println("Second element: " + pair.getSecond());

pair.setFirst(20);
pair.setSecond("World");
System.out.println("Updated first element: " + pair.getFirst());
System.out.println("Updated second element: " + pair.getSecond());

Ожидаемый вывод:

First element: 10
Second element: Hello
Updated first element: 20
Updated second element: World
В этом примере класс Pair используется для хранения пары значений: целого числа и строки. Методы getFirst() и getSecond() используются для получения значений первого и второго элементов пары соответственно, а методы setFirst() и setSecond() - для изменения значений этих элементов.

# ООП: SOLID. дз6
Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.
Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.

Применены в коде два первых принципа, а остальные описала в общем.  

1. Принцип единственной ответственности (Single Responsibility
Principle):  
Мы можем найти классы в нашем проекте, которые выполняют сразу несколько задач, и разделить их функционал на более мелкие классы.
Например, если у нас есть класс, который отвечает за чтение данных из файла и их обработку, то мы можем создать отдельный класс для работы с файлами и отдельный класс для обработки данных.  

2. Принцип открытости/закрытости (Open/Closed Principle):
Мы можем применить этот принцип, создавая абстрактные классы или интерфейсы и наследуя их для реализации новых функциональностей, не изменяя при этом существующий код. Например, если у нас есть интерфейс для работы с базой данных, то новый функциональности можно добавлять, реализуя этот интерфейс в новых классах.  

3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle):
Мы можем обратить внимание на классы, которые наследуют друг от друга, и убедиться, что любой экземпляр наследуемого класса можно заменить экземпляром базового класса без изменения желаемого поведения. Это поможет избежать ошибок при использовании классов-наследников.    

4. Принцип разделения интерфейса (Interface Segregation Principle):
Если у нас есть интерфейс, который имеет много методов, которые не используются везде, то мы можем разделить этот интерфейс на несколько отдельных интерфейсов. Таким образом, классы смогут реализовывать только те методы, которые им действительно нужны.

5. Принцип инверсии зависимостей (Dependency Inversion Principle):
Мы можем применить этот принцип, чтобы уменьшить зависимость между классами. Для этого мы можем выделить абстракции и использовать их вместо конкретной реализации. Таким образом, мы сможем легко заменить одну реализацию на другую без изменения всего кода.  